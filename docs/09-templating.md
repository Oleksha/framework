[<< Предыдущая тема](08-dependency-injector.md) | [Следующая тема >>](10-dynamic-pages.md)

### Шаблонизация

В PHP нет необходимости в шаблонизаторе, поскольку об этом может позаботиться сам язык. Но он может упростить такие вещи, как экранирование значений. Они также облегчают проведение четкой границы между логикой приложения и файлами шаблонов, которые должны помещать ваши переменные только в HTML-код.

Хорошая объясняет этот вопрос статья [ircmaxell on templating](http://blog.ircmaxell.com/2012/12/on-templating.html). Прочтите также эту [статью](http://chadminick.com/articles/simple-php-template-engine.html), чтобы узнать другое мнение по этому вопросу. Лично у меня нет четкого мнения по этому вопросу, поэтому решайте сами, какой подход вам больше подходит.

В этом уроке мы будем использовать PHP-реализацию [Mustache](https://github.com/bobthecow/mustache.php). Поэтому установите этот пакет, прежде чем продолжить (`composer require mustache/mustache`).

Другой известной альтернативой может быть [Twig](http://twig.sensiolabs.org/).

Теперь перейдем к рассмотрению исходного кода [класса engine](https://github.com/bobthecow/mustache.php/blob/master/src/Mustache/Engine.php). Как видите, класс не реализует интерфейс.

Можно было бы просто набрать подсказку для конкретного класса. Но проблема такого подхода заключается в том, что вы создаете тесную связь.

Другими словами, весь ваш код, использующий движок, будет связан с этим пакетом mustache. Если вы захотите изменить реализацию, у вас возникнут проблемы. Может быть, вы хотите перейти на Twig, может быть, вы хотите написать свой собственный класс или добавить функциональность в движок. Вы не сможете сделать это, не вернувшись назад и не изменив весь свой код, который жестко связан.

Нам же нужна свободная связь. Мы будем типизировать интерфейс, а не класс/реализацию. Таким образом, если вам нужна другая реализация, вы просто реализуете этот интерфейс в своем новом классе и инжектируете новый класс вместо него.

Вместо того чтобы редактировать код пакета, мы будем использовать [адаптер (шаблон проектирования)](http://ru.wikipedia.org/wiki/Адаптер_(шаблон_проектирования)). Это звучит гораздо сложнее, чем есть на самом деле, поэтому просто следите за тем, что мы будем делать.

Сначала определим нужный нам интерфейс. Вспомним [принцип разделения интерфейса](http://ru.wikipedia.org/wiki/Принцип_разделения_интерфейса). Это означает, что вместо больших интерфейсов с большим количеством методов мы хотим сделать каждый интерфейс как можно меньше. При необходимости класс может расширять несколько интерфейсов.

Так что же, собственно, должен делать наш шаблонизатор? На данном этапе нам нужен простой метод `render`. Создайте в папке `src/` новую папку с именем `Template` в которую поместите все, что связано с шаблонами.

В ней создайте новый интерфейс `Renderer.php`, код которого выглядит следующим образом:

```php
<?php declare(strict_types = 1);

namespace Example\Template;

interface Renderer
{
    public function render($template, $data = []) : string;
}
```

Теперь, когда с этим разобрались, давайте создадим реализацию для Mustache. В той же папке создайте файл `MustacheRenderer.php` со следующим содержанием:

```php
<?php declare(strict_types = 1);

namespace Example\Template;

use Mustache_Engine;

class MustacheRenderer implements Renderer
{
    private $engine;

    public function __construct(Mustache_Engine $engine)
    {
        $this->engine = $engine;
    }

    public function render($template, $data = []) : string
    {
        return $this->engine->render($template, $data);
    }
}
```

Как видно, адаптер очень прост. В то время как исходный класс имел большое количество методов, наш адаптер очень прост и выполняет только интерфейс.

Конечно, необходимо также добавить определение в файл `Dependencies.php`, поскольку в противном случае инжектор не будет знать, какую реализацию ему нужно инжектировать, когда вы подсказываете интерфейс. Добавьте эту строку:

`$injector->alias('Example\Template\Renderer', 'Example\Template\MustacheRenderer');`

Теперь в контроллере `Homepage` добавьте новую зависимость следующим образом:

```php
<?php declare(strict_types = 1);

namespace Example\Controllers;

use Http\Request;
use Http\Response;
use Example\Template\Renderer;

class Homepage
{
    private $request;
    private $response;
    private $renderer;

    public function __construct(
        Request $request, 
        Response $response,
        Renderer $renderer
    ) {
        $this->request = $request;
        $this->response = $response;
        $this->renderer = $renderer;
    }

...
```

Нам также придется переписать метод `show`. Обратите внимание, что хотя мы передаем простой массив, Mustache также дает возможность передавать объект контекста представления. Об этом мы поговорим позже, а пока давайте оставим все как можно проще.

```php
    public function show()
    {
        $data = [
            'name' => $this->request->getParameter('name', 'stranger'),
        ];
        $html = $this->renderer->render('Hello {{name}}', $data);
        $this->response->setContent($html);
    }
```

Теперь быстро проверьте в браузере, все ли работает. По умолчанию Mustache использует простой обработчик строк. Но нам нужны файлы шаблонов, поэтому давайте вернемся и изменим это.

Для этого нам нужно передать массив опций в конструктор `Mustache_Engine`. Поэтому давайте вернемся в файл `Dependencies.php` и добавим следующий код:

```php
$injector->define('Mustache_Engine', [
    ':options' => [
        'loader' => new Mustache_Loader_FilesystemLoader(dirname(__DIR__) . '/templates', [
            'extension' => '.html',
        ]),
    ],
]);
```

Мы передаем массив опций, потому что хотим использовать расширение `.html` вместо стандартного расширения `.mustache`. Почему? Другие языки шаблонов используют похожий синтаксис, и если мы когда-нибудь решим перейти на что-то другое, то нам не придется переименовывать все файлы шаблонов.

В корневой папке проекта создайте папку `templates`. В ней создайте файл `Homepage.html`. Содержимое этого файла должно выглядеть следующим образом:

```html
<h1>Hello World</h1>
Hello {{ name }}
```

Теперь можно вернуться к контроллеру `Homepage` и изменить строку рендеринга на `$html = $this->renderer->render('Homepage', $data);`.

Перейдите на домашнюю страницу в браузере и убедитесь, что все работает. И, как всегда, не забудьте зафиксировать изменения.

[<< Предыдущая тема](08-dependency-injector.md) | [Следующая тема >>](10-dynamic-pages.md)
