[<< previous](05-router.md) | [next >>](07-inversion-of-control.md)

### Класс диспетчеризации

В этом учебнике мы не будем реализовывать [MVC (Model-View-Controller)](https://ru.wikipedia.org/wiki/Model-View-Controller). MVC все равно не может быть реализована на PHP, по крайней мере, в том виде, в котором она была изначально задумана. Если вы хотите узнать об этом больше, прочитайте статью [A Beginner's Guide To MVC](http://blog.ircmaxell.com/2014/11/a-beginners-guide-to-mvc-for-web.html) and the followup posts.

Так что забудьте о MVC, а вместо этого давайте поговорим о [разделении ответственности](https://ru.wikipedia.org/wiki/Разделение_ответственности).

Нам понадобится описательное имя для классов, обрабатывающих запросы. В данном руководстве я буду использовать `Controllers`, поскольку это будет знакомо людям, работающим с фреймворками. Можно также назвать их `Handlers`.

Создайте новую папку внутри папки `src/` с именем `Controllers`. В этой папке мы разместим все наши классы контроллеров. В ней создайте файл `Homepage.php` со следующим кодом.

```php
<?php declare(strict_types = 1);

namespace Example\Controllers;

class Homepage
{
    public function show()
    {
        echo 'Привет мир!';
    }
}
```

Автозагрузка будет работать только в том случае, если пространство имен класса совпадает с путем к файлу, а имя файла равно имени класса. В начале я определил `Example` в качестве корневого пространства имен приложения, поэтому оно ссылается на папку `src/`.

Теперь давайте изменим маршрут hello world так, чтобы он вызывал метод вашего нового класса вместо закрытия. Измените файл `Routes.php` следующим образом:

```php
return [
    ['GET', '/', ['Example\Controllers\Homepage', 'show']],
];
```

Вместо простого вызываемого объекта теперь передается массив. Первое значение - это полное имя класса, второе - имя метода, который вы хотите вызвать.

Для того чтобы это работало, необходимо также произвести небольшой рефакторинг части маршрутизации в файле `Bootstrap.php`:

```php
case \FastRoute\Dispatcher::FOUND:
    $className = $routeInfo[1][0];
    $method = $routeInfo[1][1];
    $vars = $routeInfo[2];
    
    $class = new $className;
    $class->$method($vars);
    break;
```

Таким образом, вместо того чтобы просто вызывать метод, вы теперь подключаете объект, а затем вызываете в нем нужный метод.

Теперь, если вы посетите `http://localhost:8000/`, все должно работать. Если нет, вернитесь назад и отладьте. И, конечно, не забудьте зафиксировать изменения.

[<< previous](05-router.md) | [next >>](07-inversion-of-control.md)
